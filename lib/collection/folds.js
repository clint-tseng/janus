// Generated by CoffeeScript 1.12.2
(function() {
  var Varying, foldBase, folds;

  Varying = require('../core/varying').Varying;

  foldBase = function(update) {
    return function(collection) {
      var result, watched;
      result = new Varying(null);
      watched = 0;
      collection.watchLength().react(function(length) {
        var fn, i, idx, ref, ref1;
        fn = function(idx) {
          return collection.watchAt(idx).react(function(value) {
            return result.set(update(value, idx, collection));
          });
        };
        for (idx = i = ref = watched, ref1 = length; ref <= ref1 ? i < ref1 : i > ref1; idx = ref <= ref1 ? ++i : --i) {
          fn(idx);
        }
        return watched = length;
      });
      return result;
    };
  };

  folds = {
    any: foldBase(function(value, _, collection) {
      var existTrue, i, item, len, ref;
      if (value !== true) {
        existTrue = false;
        ref = collection.list;
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          if (item === true) {
            existTrue = true;
            break;
          }
        }
        return existTrue;
      } else {
        return true;
      }
    }),
    apply: function(collection, f) {
      return collection.watchLength().flatMap(function(length) {
        var idx;
        return Varying.all((function() {
          var i, ref, results;
          results = [];
          for (idx = i = 0, ref = collection.length; 0 <= ref ? i <= ref : i >= ref; idx = 0 <= ref ? ++i : --i) {
            results.push(collection.watchAt(idx));
          }
          return results;
        })()).map(f);
      });
    },
    min: function(collection) {
      var last, update;
      last = null;
      update = function(value, idx, collection) {
        var largest, x;
        return last = last === null ? value : value <= last ? value : (largest = null, [
          (function() {
            var i, len, ref, results;
            ref = collection.list;
            results = [];
            for (i = 0, len = ref.length; i < len; i++) {
              x = ref[i];
              results.push(largest = largest != null ? Math.min(largest, x) : x);
            }
            return results;
          })()
        ], last = largest);
      };
      return foldBase(update)(collection);
    },
    max: function(collection) {
      var last, update;
      last = null;
      update = function(value, idx, collection) {
        var largest, x;
        return last = last === null ? value : value >= last ? value : (largest = null, [
          (function() {
            var i, len, ref, results;
            ref = collection.list;
            results = [];
            for (i = 0, len = ref.length; i < len; i++) {
              x = ref[i];
              results.push(largest = largest != null ? Math.max(largest, x) : x);
            }
            return results;
          })()
        ], last = largest);
      };
      return foldBase(update)(collection);
    },
    sum: function(collection) {
      var last, update, values;
      values = [];
      last = 0;
      update = function(value, idx, collection) {
        var diff, ref;
        diff = (value != null ? value : 0) - ((ref = values[idx]) != null ? ref : 0);
        values[idx] = value;
        return last += diff;
      };
      return foldBase(update)(collection);
    },
    join: function(collection, joiner) {
      return foldBase(function(_, _2, collection) {
        return collection.list.join(joiner);
      })(collection);
    },
    scanl: function(collection, memo, f) {
      var result, self;
      self = new Varying();
      result = collection.enumeration().flatMap(function(idx) {
        return self.flatMap(function(result) {
          var prev;
          if (result == null) {
            return;
          }
          prev = idx === 0 ? Varying.of(memo) : result.watchAt(idx - 1);
          return Varying.mapAll(f, prev, collection.watchAt(idx));
        });
      });
      self.set(result);
      return result;
    },
    foldl: function(collection, memo, f) {
      return folds.scanl(collection, memo, f).watchAt(-1);
    }
  };

  module.exports = folds;

}).call(this);
