// Generated by CoffeeScript 1.12.2
(function() {
  var Traversal, Varying, deepSet, defer, delegate, fix, identity, isFunction, match, matchAction, nothing, otherwise, processElem, processRoot, recurse, reducer, ref, ref1, ref2, value, varying;

  Varying = require('../core/varying').Varying;

  ref = require('../util/util'), identity = ref.identity, isFunction = ref.isFunction, deepSet = ref.deepSet, fix = ref.fix;

  ref1 = require('../core/case'), match = ref1.match, otherwise = ref1.otherwise;

  ref2 = require('../core/types').traversal, recurse = ref2.recurse, delegate = ref2.delegate, defer = ref2.defer, varying = ref2.varying, value = ref2.value, nothing = ref2.nothing;

  matchAction = function(local) {
    return fix(function(rematch) {
      return match(recurse(function(into, context) {
        return local.root(into, local, context != null ? context : local.context);
      }), delegate(function(to, context) {
        var newlocal;
        newlocal = Object.assign({}, local, {
          context: context
        });
        return matchAction(newlocal)(to(local.key, local.value, local.obj, local.attribute, context != null ? context : local.context));
      }), defer(function(to, context) {
        var newlocal;
        newlocal = Object.assign({}, local, {
          context: context,
          map: to
        });
        return matchAction(newlocal)(to(local.key, local.value, local.obj, local.attribute, context != null ? context : local.context));
      }), varying(function(v) {
        var mapped;
        mapped = v.flatMap(function(x) {
          return rematch(x);
        });
        if (local.immediate === true) {
          return mapped.get();
        } else {
          return mapped;
        }
      }), value(function(x) {
        return x;
      }), nothing(function() {
        return void 0;
      }));
    });
  };

  processElem = function(general) {
    return function(key, value) {
      var attribute, local, obj;
      obj = general.obj;
      if (obj.isModel === true) {
        attribute = obj.attribute(key);
      }
      local = Object.assign({}, general, {
        key: key,
        value: value,
        attribute: attribute
      });
      return matchAction(local)(general.map(key, value, obj, attribute, general.context));
    };
  };

  processRoot = function(general, process) {
    var matchRootAction, ref3;
    matchRootAction = match(recurse(function(into, context) {
      return process(Object.assign({}, general, {
        obj: into,
        context: context
      }));
    }), varying(function(v, context) {
      var mapped;
      mapped = v.flatMap(function(x) {
        return matchRootAction(x);
      });
      if (general.immediate === true) {
        return mapped.get();
      } else {
        return mapped;
      }
    }), otherwise(function(x) {
      return matchAction(general)(x);
    }));
    return matchRootAction(((ref3 = general.recurse) != null ? ref3 : recurse)(general.obj, general.context));
  };

  reducer = function(general, resource) {
    return function() {
      if (general.reduce != null) {
        return Varying.managed(resource(), general.reduce);
      } else {
        return resource()();
      }
    };
  };

  Traversal = {
    asNatural: function(obj, fs, context) {
      var fmapper, general;
      if (context == null) {
        context = {};
      }
      general = Object.assign({}, fs, {
        obj: obj,
        context: context,
        root: Traversal.asNatural
      });
      fmapper = processElem(general);
      return processRoot(general, function() {
        return general.obj.flatMapPairs(fmapper);
      });
    },
    asList: function(obj, fs, context) {
      var fmapper, general;
      if (context == null) {
        context = {};
      }
      general = Object.assign({}, fs, {
        obj: obj,
        context: context,
        root: Traversal.asList
      });
      fmapper = processElem(general);
      return processRoot(general, reducer(general, function() {
        return function() {
          return general.obj.enumeration().flatMapPairs(fmapper);
        };
      }));
    },
    getNatural: function(obj, fs, context) {
      var attribute, i, key, len, local, ref3, result, set, val;
      if (context == null) {
        context = {};
      }
      result = obj.isMappable === true ? [] : {};
      set = obj.isMappable === true ? (function(k, v) {
        return result[k] = v;
      }) : (function(k, v) {
        return deepSet(result, k)(v);
      });
      ref3 = obj.enumerate();
      for (i = 0, len = ref3.length; i < len; i++) {
        key = ref3[i];
        val = obj.get(key);
        if (obj.isModel === true) {
          attribute = obj.attribute(key);
        }
        local = Object.assign({}, fs, {
          obj: obj,
          key: key,
          val: val,
          attribute: attribute,
          context: context,
          immediate: true,
          root: Traversal.getNatural
        });
        set(key, matchAction(local)(local.map(key, val, obj, attribute, context)));
      }
      return result;
    },
    getArray: function(obj, fs, context) {
      var attribute, key, local, ref3, val;
      if (context == null) {
        context = {};
      }
      return ((ref3 = fs.reduce) != null ? ref3 : identity)((function() {
        var i, len, ref3, results;
        ref3 = obj.enumerate();
        results = [];
        for (i = 0, len = ref3.length; i < len; i++) {
          key = ref3[i];
          val = obj.get(key);
          if (obj.isModel === true) {
            attribute = obj.attribute(key);
          }
          local = Object.assign({}, fs, {
            obj: obj,
            key: key,
            val: val,
            attribute: attribute,
            context: context,
            immediate: true,
            root: Traversal.getArray
          });
          results.push(matchAction(local)(local.map(key, val, obj, attribute, context)));
        }
        return results;
      })());
    }
  };

  Traversal["default"] = {
    serialize: {
      map: function(k, v, _, attribute) {
        var ref3;
        if (attribute != null) {
          return value(attribute.serialize());
        } else if (v != null) {
          if ((ref3 = v.constructor) != null ? ref3.prototype.hasOwnProperty('serialize') : void 0) {
            return value(v.serialize());
          } else if (v.isEnumerable === true) {
            return recurse(v);
          } else {
            return value(v);
          }
        } else {
          return nothing;
        }
      }
    },
    diff: {
      recurse: function(obj, arg) {
        var other;
        other = arg.other;
        if (((obj != null ? obj.isEnumerable : void 0) === true && (other != null ? other.isEnumerable : void 0) === true) && (obj.isMappable === other.isMappable)) {
          return varying(Varying.mapAll(obj.watchLength(), other.watchLength(), function(la, lb) {
            if (la !== lb) {
              return value(true);
            } else {
              return recurse(obj, {
                other: other
              });
            }
          }));
        } else {
          return value(new Varying(obj !== other));
        }
      },
      map: function(k, va, obj, attribute, arg) {
        var other;
        other = arg.other;
        return varying(other.watch(k).map(function(vb) {
          if ((va != null) && (vb != null)) {
            if (((va != null ? va.isEnumerable : void 0) === true && (vb != null ? vb.isEnumerable : void 0) === true) && (va.isMappable === vb.isMappable)) {
              return recurse(va, {
                other: vb
              });
            } else {
              return value(va !== vb);
            }
          } else {
            return value((va != null) || (vb != null));
          }
        }));
      },
      reduce: function(list) {
        return list.any(identity);
      }
    }
  };

  module.exports = {
    Traversal: Traversal
  };

}).call(this);
