// Generated by CoffeeScript 1.6.2
(function() {
  var DerivedList, Enumeration, KeyList, Struct, Varying, deepGet, traverse, traverseAll, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Varying = require('../core/varying').Varying;

  DerivedList = require('../collection/list').DerivedList;

  Struct = require('./struct').Struct;

  _ref = require('../util/util'), traverse = _ref.traverse, traverseAll = _ref.traverseAll, deepGet = _ref.deepGet;

  KeyList = (function(_super) {
    __extends(KeyList, _super);

    function KeyList(struct, options) {
      var ptr, scanStruct, _ref1, _ref2,
        _this = this;

      this.struct = struct;
      if (options == null) {
        options = {};
      }
      KeyList.__super__.constructor.call(this);
      this.scope = (_ref1 = options.scope) != null ? _ref1 : 'all';
      this.include = (_ref2 = options.include) != null ? _ref2 : 'values';
      this._trackedKeys = {};
      scanStruct = function(struct) {
        return traverse(struct.attributes, function(key) {
          return _this._addKey(key.join('.'));
        });
      };
      if (this.scope === 'all') {
        ptr = this.struct;
        while (ptr != null) {
          scanStruct(ptr);
          ptr = ptr._parent;
        }
      } else if (this.scope === 'direct') {
        scanStruct(this.struct);
      }
      this.listenTo(struct, 'anyChanged', function(key, newValue, oldValue) {
        var ownValue;

        if (_this.scope === 'direct') {
          ownValue = deepGet(_this.struct.attributes, key);
          if (ownValue !== newValue) {
            return;
          }
        }
        if ((newValue != null) && (oldValue == null)) {
          return _this._addKey(key);
        } else if ((oldValue != null) && (newValue == null)) {
          return _this._removeKey(key);
        }
      });
    }

    KeyList.prototype._addKey = function(key) {
      var i, parts, _i, _ref1, _results;

      if (this._trackedKeys[key] === true) {
        return;
      }
      if (this.include === 'all') {
        parts = key.split('.');
        _results = [];
        for (i = _i = _ref1 = parts.length; _i > 0; i = _i += -1) {
          key = parts.slice(0, i).join('.');
          if (this._trackedKeys[key] === true) {
            break;
          }
          this._trackedKeys[key] = true;
          _results.push(this._add(key));
        }
        return _results;
      } else {
        this._trackedKeys[key] = true;
        return this._add(key);
      }
    };

    KeyList.prototype._removeKey = function(key) {
      var idx, k, _i, _len, _ref1;

      delete this._trackedKeys[key];
      this._removeAt(this.list.indexOf(key));
      if (this.include === 'all') {
        _ref1 = this.list;
        for (idx = _i = 0, _len = _ref1.length; _i < _len; idx = ++_i) {
          k = _ref1[idx];
          if (!(k.indexOf(key) === 0)) {
            continue;
          }
          console.log('attempted removal');
          delete this._trackedKeys[k];
          this._removeAt(idx);
        }
      }
      return null;
    };

    KeyList.prototype.mapPairs = function(f) {
      var _this = this;

      return this.map(function(key) {
        return Varying.flatMapAll(f, new Varying(key), _this.model.watch(key));
      });
    };

    KeyList.prototype.flatMapPairs = function(f) {
      var _this = this;

      return this.flatMap(function(key) {
        return Varying.flatMapAll(f, new Varying(key), _this.model.watch(key));
      });
    };

    KeyList.prototype.mapToStruct = function(f) {
      var key, result, _i, _len, _ref1,
        _this = this;

      result = new Struct();
      _ref1 = this.list;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        key = _ref1[_i];
        result.set(key, f(key, this.model.get(key)));
      }
      result.listenTo(this, 'added', function(key) {
        return result.set(key, f(key, _this.model.get(key)));
      });
      result.listenTo(this, 'removed', function(key) {
        return result.unset(key);
      });
      return result;
    };

    KeyList.prototype.flatMapToStruct = function(f, klass) {
      var add, key, result, varieds, _i, _len, _ref1,
        _this = this;

      if (klass == null) {
        klass = Struct;
      }
      result = new klass();
      varieds = {};
      add = function(key) {
        return varieds[key] = _this.model.watch(key).flatMap(function(value) {
          return f(key, value);
        }).reactNow(function(x) {
          return result.set(key, x);
        });
      };
      _ref1 = this.list;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        key = _ref1[_i];
        add(key);
      }
      result.listenTo(this, 'added', add);
      result.listenTo(this, 'removed', function(key) {
        varieds[key].stop();
        delete varieds[key];
        return result.unset(key);
      });
      result.on('destroying', function() {
        var varied, _, _results;

        _results = [];
        for (_ in varieds) {
          varied = varieds[_];
          _results.push(varied.stop());
        }
        return _results;
      });
      return result;
    };

    return KeyList;

  })(DerivedList);

  Enumeration = {
    get: function(struct, options) {
      var include, ptr, result, scanStruct, scope, traverser, _ref1, _ref2,
        _this = this;

      if (options == null) {
        options = {};
      }
      scope = (_ref1 = options.scope) != null ? _ref1 : 'all';
      include = (_ref2 = options.include) != null ? _ref2 : 'values';
      result = [];
      traverser = include === 'values' ? traverse : include === 'all' ? traverseAll : void 0;
      scanStruct = function(struct) {
        return traverser(struct.attributes, function(key) {
          if (!(result.indexOf(key) >= 0)) {
            return result.push(key);
          }
        });
      };
      if (scope === 'all') {
        ptr = struct;
        while (ptr != null) {
          scanStruct(ptr);
          ptr = ptr._parent;
        }
      } else if (scope === 'direct') {
        scanStruct(struct);
      }
      return result;
    },
    watch: function(struct, options) {
      return new KeyList(struct, options);
    }
  };

  module.exports = {
    KeyList: KeyList,
    Enumeration: Enumeration
  };

}).call(this);
