// Generated by CoffeeScript 1.12.2
(function() {
  var capitalize, defcase, extendNew, isFunction, isPlainObject, match, otherwise, ref, unapply,
    slice = [].slice;

  ref = require('../util/util'), extendNew = ref.extendNew, capitalize = ref.capitalize, isPlainObject = ref.isPlainObject, isFunction = ref.isFunction;

  otherwise = function(value) {
    var instance;
    instance = new String('otherwise');
    instance.value = value;
    instance["case"] = otherwise;
    return instance;
  };

  otherwise.type = 'otherwise';

  defcase = function() {
    var caseProps, fn, inTypes, j, k, len, namespace, set, type, types, v;
    namespace = arguments[0], inTypes = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    set = {};
    types = {};
    for (j = 0, len = inTypes.length; j < len; j++) {
      type = inTypes[j];
      if (isPlainObject(type)) {
        for (k in type) {
          v = type[k];
          types[k] = v;
        }
      } else {
        types[type] = {};
      }
    }
    fn = function(type, caseProps) {
      var kase, props;
      props = {
        map: function(f) {
          return kase(f(this.value));
        },
        unapply: function(x, additional) {
          if (isFunction(x)) {
            return x.apply(null, [this.value].concat(slice.call(additional)));
          } else {
            return x;
          }
        },
        toString: function() {
          return this + ": " + this.value;
        }
      };
      kase = function(value) {
        var fType, fn1, instance, prop, ref1, val;
        instance = new String('' + type);
        instance.type = type;
        instance.value = value;
        fn1 = function(fType) {
          instance[fType + 'OrElse'] = function(x) {
            if (type === fType) {
              return this.value;
            } else {
              return x;
            }
          };
          instance['get' + capitalize(fType)] = function() {
            if (type === fType) {
              return this.value;
            } else {
              return this;
            }
          };
          return instance['map' + capitalize(fType)] = function(f) {
            if (type === fType) {
              return kase(f(this.value));
            } else {
              return this;
            }
          };
        };
        for (fType in types) {
          fn1(fType);
        }
        instance["case"] = kase;
        ref1 = extendNew(props, caseProps);
        for (prop in ref1) {
          val = ref1[prop];
          instance[prop] = val;
        }
        return instance;
      };
      kase.isCase = true;
      kase.type = type;
      kase.set = set;
      kase.namespace = namespace;
      kase.match = function(x, f_) {
        var matches;
        matches = (x != null ? x.type : void 0) === type;
        if (isFunction(f_)) {
          if (matches) {
            return f_(x.value);
          }
        } else {
          return matches;
        }
      };
      return set[type] = kase;
    };
    for (type in types) {
      caseProps = types[type];
      fn(type, caseProps);
    }
    return set;
  };

  unapply = function(target, handler, additional, unapply) {
    if (unapply == null) {
      unapply = true;
    }
    if (isFunction(handler)) {
      if (isFunction(target != null ? target.unapply : void 0) && unapply === true) {
        return target.unapply(handler, additional);
      } else {
        return handler.apply(null, [target].concat(slice.call(additional)));
      }
    } else {
      return handler;
    }
  };

  match = function() {
    var args, first, hasOtherwise, i, kase, namespace, ref1, ref2, ref3, ref4, seen, set, x;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    first = args[0];
    set = (ref1 = (ref2 = first != null ? first["case"] : void 0) != null ? ref2 : first) != null ? ref1.set : void 0;
    namespace = (ref3 = (ref4 = first != null ? first["case"] : void 0) != null ? ref4 : first) != null ? ref3.namespace : void 0;
    seen = {};
    hasOtherwise = false;
    i = 0;
    while (i < args.length) {
      x = args[i];
      kase = x["case"] != null ? x["case"] : x;
      if (kase.type === 'otherwise') {
        hasOtherwise = true;
      } else {
        if (kase.namespace !== namespace) {
          throw new Error("found a case of some other set!");
        }
        seen[kase.type] = true;
      }
      i += x["case"] != null ? 1 : 2;
    }
    if (hasOtherwise === false) {
      for (kase in set) {
        if (seen[kase] !== true) {
          throw new Error('not all cases covered!');
        }
      }
    }
    return function() {
      var additional, handler, ref5, ref6, target;
      target = arguments[0], additional = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      i = 0;
      while (i < args.length) {
        x = args[i];
        if (x["case"] != null) {
          kase = x["case"];
          handler = x.value;
        } else {
          kase = args[i];
          handler = args[i + 1];
        }
        if (kase.type === 'otherwise') {
          return unapply(target, handler, additional, false);
        }
        if (kase.type.valueOf() === (target != null ? target.valueOf() : void 0) && ((ref5 = (ref6 = target != null ? target["case"] : void 0) != null ? ref6 : target) != null ? ref5.namespace : void 0) === namespace) {
          return unapply(target, handler, additional);
        }
        i += x["case"] != null ? 1 : 2;
      }
    };
  };

  module.exports = {
    defcase: defcase,
    match: match,
    otherwise: otherwise
  };

}).call(this);
