// Generated by CoffeeScript 1.12.2
(function() {
  var Case, Otherwise, capitalize, defaultOptions, defaultUnapplies, defcase, deftype, fullDefcase, identity, isArray, isFunction, isPlainObject, isString, match, otherwise, ref, singleMatch,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  ref = require('../util/util'), isPlainObject = ref.isPlainObject, isString = ref.isString, isArray = ref.isArray, isFunction = ref.isFunction, capitalize = ref.capitalize, identity = ref.identity;

  Case = (function() {
    Case.prototype.isCaseInstance = true;

    function Case(x11, unapply) {
      this.x1 = x11;
      this.unapply = unapply;
    }

    Case.prototype.map = function(f) {
      return new this.constructor(void 0, (function(_this) {
        return function(g) {
          return g(_this.unapply(f));
        };
      })(this));
    };

    Case.prototype.toString = function() {
      return "case[" + this.name + "]: " + this.x1;
    };

    return Case;

  })();

  singleMatch = function(type) {
    return function(x, f_) {
      if (f_ != null) {
        if (x instanceof type) {
          return x.unapply(f_);
        }
      } else {
        return x instanceof type;
      }
    };
  };

  defaultUnapplies = [
    function(kase) {
      return function(x1) {
        return new kase(x1, function(f) {
          return f();
        });
      };
    }, function(kase) {
      return function(x1) {
        return new kase(x1, function(f) {
          return f(x1);
        });
      };
    }, function(kase) {
      return function(x1, x2) {
        return new kase(x1, function(f) {
          return f(x1, x2);
        });
      };
    }, function(kase) {
      return function(x1, x2, x3) {
        return new kase(x1, function(f) {
          return f(x1, x2, x3);
        });
      };
    }
  ];

  deftype = function(base, name, abstract) {
    return (function(superClass) {
      extend(_Class, superClass);

      function _Class() {
        return _Class.__super__.constructor.apply(this, arguments);
      }

      _Class.prototype.abstract = abstract;

      _Class.prototype.name = name;

      return _Class;

    })(base);
  };

  defaultOptions = {
    arity: 1
  };

  fullDefcase = function(options) {
    return function() {
      var Name, args, base, ctor, ctors, getter, name, recurse, self, type, typeArity, types, unapplies;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      options = Object.assign({}, defaultOptions, options);
      types = {};
      unapplies = {};
      base = (function(superClass) {
        extend(_Class, superClass);

        function _Class() {
          return _Class.__super__.constructor.apply(this, arguments);
        }

        _Class.prototype.types = types;

        return _Class;

      })(Case);
      recurse = function(xs, localBase) {
        var i, k, len, v, x;
        for (i = 0, len = xs.length; i < len; i++) {
          x = xs[i];
          if (isString(x)) {
            types[x] = deftype(localBase, x, false);
          } else {
            for (k in x) {
              v = x[k];
              if (isPlainObject(v)) {
                v = [v];
              }
              if (isArray(v)) {
                recurse(v, (types[k] = deftype(localBase, k, true)));
              } else {
                unapplies[k] = v;
                types[k] = deftype(localBase, k, false);
              }
            }
          }
        }
      };
      recurse(args, base);
      ctors = {};
      for (name in types) {
        type = types[name];
        ctors[name] = ctor = unapplies[name] != null ? unapplies[name](type) : defaultUnapplies[options.arity](type);
        Object.assign(ctor, {
          isCase: true,
          type: type,
          match: singleMatch(type)
        });
      }
      for (name in types) {
        type = types[name];
        Name = capitalize(name);
        self = function() {
          return this;
        };
        typeArity = ctors[name].length;
        getter = typeArity === 0 ? (function() {}) : typeArity === 1 ? function() {
          return this.unapply(identity);
        } : function() {
          return this.unapply(function() {
            var xs;
            xs = 1 <= arguments.length ? slice.call(arguments, 0) : [];
            return xs;
          });
        };
        base.prototype.get = getter;
        base.prototype[name + "OrElse"] = identity;
        type.prototype[name + "OrElse"] = getter;
        base.prototype["get" + Name] = self;
        type.prototype["get" + Name] = getter;
        base.prototype["map" + Name] = self;
        type.prototype["map" + Name] = Case.prototype.map;
      }
      return ctors;
    };
  };

  defcase = fullDefcase();

  defcase.withOptions = fullDefcase;

  Otherwise = (function() {
    function Otherwise(x11) {
      this.x1 = x11;
    }

    return Otherwise;

  })();

  otherwise = function(x1) {
    return new Otherwise(x1);
  };

  match = function() {
    var conds;
    conds = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return function(kase) {
      var cond, i, len;
      if ((kase != null ? kase.abstract : void 0) === true) {
        return;
      }
      for (i = 0, len = conds.length; i < len; i++) {
        cond = conds[i];
        if (kase instanceof cond.constructor) {
          return kase.unapply(cond.x1);
        }
        if (cond instanceof Otherwise) {
          return cond.x1(kase);
        }
      }
    };
  };

  module.exports = {
    defcase: defcase,
    match: match,
    otherwise: otherwise
  };

}).call(this);
