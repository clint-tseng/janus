// Generated by CoffeeScript 1.12.2
(function() {
  var Varying, build, cases, fix, from, identity, match, otherwise, ref, ref1, terminus, tryApply, tryPoint, val;

  Varying = require('./varying').Varying;

  cases = require('./types').from;

  ref = require('./case'), match = ref.match, otherwise = ref.otherwise;

  ref1 = require('../util/util'), fix = ref1.fix, identity = ref1.identity;

  tryApply = function(x, f) {
    return function(point) {
      var ref2, result;
      if (((ref2 = (result = x(point))) != null ? ref2.isVarying : void 0) === true) {
        return f(result);
      } else {
        return tryApply(result, f);
      }
    };
  };

  tryPoint = function(kase) {
    return fix(function(wrapped) {
      return function(point) {
        var ref2, result;
        if (((ref2 = (result = point(kase))) != null ? ref2.isVarying : void 0) === true) {
          return result;
        } else {
          return wrapped;
        }
      };
    });
  };

  val = function(conjunction, applicant, rest) {
    var append, applicants;
    if (rest == null) {
      rest = [];
    }
    append = function(f) {
      return val(conjunction, tryApply(applicant, f), rest);
    };
    applicants = rest.concat(applicant);
    return {
      map: function(f) {
        return append(function(v) {
          return v.map(f);
        });
      },
      flatMap: function(f) {
        return append(function(v) {
          return v.flatMap(f);
        });
      },
      watch: function(attr) {
        return append(function(v) {
          return v.flatMap(function(x) {
            var ref2;
            return (ref2 = x != null ? typeof x.watch === "function" ? x.watch(attr) : void 0 : void 0) != null ? ref2 : null;
          });
        });
      },
      attribute: function(attr) {
        return append(function(v) {
          return v.map(function(x) {
            var ref2;
            return (ref2 = x != null ? typeof x.attribute === "function" ? x.attribute(attr) : void 0 : void 0) != null ? ref2 : null;
          });
        });
      },
      pipe: function(f) {
        return append(f);
      },
      asVarying: function() {
        return append(function(v) {
          return new Varying(v);
        });
      },
      all: terminus(applicants),
      and: conjunction(applicants)
    };
  };

  build = function(cases) {
    var base, conjunction, kase, makeVal, methods, name;
    methods = {};
    makeVal = function(kase) {
      return function(applicants) {
        return function(x) {
          return val(conjunction, tryPoint(kase(x)), applicants);
        };
      };
    };
    for (name in cases) {
      kase = cases[name];
      if (name !== 'dynamic') {
        methods[name] = makeVal(kase);
      }
    }
    base = cases.dynamic != null ? makeVal(cases.dynamic) : (function() {
      return {};
    });
    conjunction = function(applicants) {
      var k, result, v;
      result = base(applicants);
      for (k in methods) {
        v = methods[k];
        result[k] = v(applicants);
      }
      return result;
    };
    return conjunction();
  };

  terminus = function(applicants, map) {
    var result;
    if (map == null) {
      map = identity;
    }
    result = {
      map: function(f) {
        return terminus(applicants, function(x) {
          return map(x).map(f);
        });
      },
      flatMap: function(f) {
        return terminus(applicants, function(x) {
          return map(x).flatMap(f);
        });
      },
      point: function(f) {
        var applicant, applied, v;
        if (f == null) {
          f = identity;
        }
        applied = (function() {
          var i, len, ref2, results;
          results = [];
          for (i = 0, len = applicants.length; i < len; i++) {
            applicant = applicants[i];
            results.push((ref2 = typeof applicant === "function" ? applicant(f) : void 0) != null ? ref2 : applicant);
          }
          return results;
        })();
        v = applicants.length === 1 ? map(Varying.of(applied[0])) : map(Varying.all((function() {
          var i, len, results;
          results = [];
          for (i = 0, len = applied.length; i < len; i++) {
            applicant = applied[i];
            results.push(Varying.of(applicant));
          }
          return results;
        })()));
        v.point = terminus(applied, map).point;
        return v;
      }
    };
    result.all = result;
    return result;
  };

  from = build(cases);

  from.build = build;

  module.exports = from;

}).call(this);
