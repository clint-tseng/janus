// Generated by CoffeeScript 1.12.2
(function() {
  var Case, Otherwise, capitalize, defcase, deftype, identity, isPlainObject, isString, match, otherwise, ref, singleMatch,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  ref = require('../util/util'), isPlainObject = ref.isPlainObject, isString = ref.isString, capitalize = ref.capitalize, identity = ref.identity;

  Case = (function() {
    Case.prototype.isCaseInstance = true;

    function Case(_value) {
      this._value = _value;
    }

    Case.prototype.get = function() {
      return this._value;
    };

    Case.prototype.map = function(f) {
      return new this.constructor(f(this._value));
    };

    Case.prototype.toString = function() {
      return "case[" + this.name + "]: " + this._value;
    };

    return Case;

  })();

  singleMatch = function(type) {
    return function(x, f_) {
      if (f_ != null) {
        if (x instanceof type) {
          return f_(x._value);
        }
      } else {
        return x instanceof type;
      }
    };
  };

  deftype = function(base, name, abstract) {
    return (function(superClass) {
      extend(_Class, superClass);

      function _Class() {
        return _Class.__super__.constructor.apply(this, arguments);
      }

      _Class.prototype.abstract = abstract;

      _Class.prototype.name = name;

      return _Class;

    })(base);
  };

  defcase = function() {
    var Name, args, base, ctor, ctors, name, recurse, self, type, types;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    types = {};
    base = (function(superClass) {
      extend(_Class, superClass);

      function _Class() {
        return _Class.__super__.constructor.apply(this, arguments);
      }

      _Class.prototype.types = types;

      return _Class;

    })(Case);
    recurse = function(xs, localBase) {
      var i, k, len, v, x;
      for (i = 0, len = xs.length; i < len; i++) {
        x = xs[i];
        if (isString(x)) {
          types[x] = deftype(localBase, x, false);
        } else {
          for (k in x) {
            v = x[k];
            if (isPlainObject(v)) {
              v = [v];
            }
            recurse(v, (types[k] = deftype(localBase, k, true)));
          }
        }
      }
    };
    recurse(args, base);
    ctors = {};
    for (name in types) {
      type = types[name];
      ctors[name] = ctor = (function(T) {
        return function(x) {
          return new T(x);
        };
      })(type);
      Object.assign(ctor, {
        isCase: true,
        type: type,
        match: singleMatch(type)
      });
    }
    for (name in types) {
      type = types[name];
      if (!(type.prototype.abstract !== true)) {
        continue;
      }
      Name = capitalize(name);
      self = function() {
        return this;
      };
      base.prototype[name + "OrElse"] = identity;
      type.prototype[name + "OrElse"] = Case.prototype.get;
      base.prototype["get" + Name] = self;
      type.prototype["get" + Name] = Case.prototype.get;
      base.prototype["map" + Name] = self;
      type.prototype["map" + Name] = Case.prototype.map;
    }
    return ctors;
  };

  Case.build = defcase;

  Otherwise = (function() {
    function Otherwise(_f) {
      this._f = _f;
    }

    return Otherwise;

  })();

  otherwise = function(f) {
    return new Otherwise(f);
  };

  match = function() {
    var conds;
    conds = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return function(kase) {
      var cond, i, len;
      if ((kase != null ? kase.abstract : void 0) === true) {
        return;
      }
      for (i = 0, len = conds.length; i < len; i++) {
        cond = conds[i];
        if (kase instanceof cond.constructor) {
          return cond._value(kase._value);
        }
        if (cond instanceof Otherwise) {
          return cond._f(kase);
        }
      }
    };
  };

  module.exports = {
    Case: Case,
    match: match,
    otherwise: otherwise
  };

}).call(this);
